use super::{
    WatEmitter, ARRAY_HEADER_SIZE, ARRAY_KIND_BOOL, ARRAY_KIND_I64, ARRAY_KIND_REF, ARRAY_KIND_U8,
    HEAP_AUX_OFFSET, HEAP_FLAGS_OFFSET, HEAP_KIND_ARRAY, HEAP_KIND_FREE, HEAP_KIND_OBJECT,
    HEAP_KIND_SHIFT, HEAP_KIND_STRING, HEAP_LEN_OFFSET, HEAP_TYPE_ID_MASK, OBJECT_HEADER_SIZE,
    STRING_HEADER_SIZE, TRACE_STACK_DATA_OFFSET, TRACE_STACK_PTR_OFFSET, TRACE_STACK_SLOTS,
    TRAP_ARRAY_OOM, TRAP_HEAP_HEADER, TRAP_KIND_BYTES, TRAP_KIND_STRING, TRAP_STRING_PARSE,
    TRAP_TRACE_OOM, TRAP_UTF8_INVALID, TRAP_NULL_DEREF,
};

pub(super) fn emit_heap_runtime(
    emitter: &mut WatEmitter,
    export_memory: bool,
    needs_validate_utf8: bool,
    needs_io: bool,
    heap_start: i32,
) {
    emitter.push_line("(import \"env\" \"bd_trap\" (func $bd_trap (param i32)))");
    if needs_validate_utf8 {
        emitter.push_line(
            "(import \"env\" \"bd_validate_utf8\" (func $bd_validate_utf8 (param i32 i32) (result i32)))",
        );
    }
    if needs_io {
        emitter.push_line("(import \"env\" \"bd_print\" (func $bd_print (param i32 i32)))");
        emitter.push_line("(import \"env\" \"bd_read_line_len\" (func $bd_read_line_len (result i32)))");
        emitter.push_line("(import \"env\" \"bd_read_line_fill\" (func $bd_read_line_fill (param i32 i32)))");
    }
    emitter.push_line("(memory $mem 1)");
    if export_memory {
        emitter.push_line("(export \"memory\" (memory $mem))");
    }
    emitter.push_line(format!(
        "(global $heap (mut i32) (i32.const {heap_start}))"
    ));
    emitter.push_line("(global $free_list (mut i32) (i32.const 0))");
    emitter.push_line("(global $gc_last_freed (mut i32) (i32.const 0))");

    emitter.push_line(
        "(func $bd_alloc_from_free (param $size i32) (result i32) (local $prev i32) (local $cur i32) (local $cur_size i32) (local $next i32) (local $remain i32) (local $split i32)",
    );
    emitter.indent();
    emitter.push_line("global.get $free_list");
    emitter.push_line("local.set $cur");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $prev");
    let free_exit = "free_exit";
    let free_loop = "free_loop";
    emitter.push_line(format!("block ${free_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${free_loop}"));
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${free_exit}"));
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $cur_size");
    emitter.push_line("local.get $cur_size");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $next");
    emitter.push_line("local.get $cur_size");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $remain");
    emitter.push_line("local.get $remain");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $split");
    emitter.push_line("local.get $split");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_FREE << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $split");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $split");
    emitter.push_line("local.get $remain");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $split");
    emitter.push_line("local.get $next");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $prev");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $split");
    emitter.push_line("global.set $free_list");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $split");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $cur");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $cur_size");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $prev");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $next");
    emitter.push_line("global.set $free_list");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $next");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $cur");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $cur");
    emitter.push_line("local.set $prev");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $cur");
    emitter.push_line(format!("br ${free_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("i32.const 0");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_alloc (param $size i32) (result i32) (local $ptr i32) (local $new_heap i32) (local $pages_needed i32) (local $cur_pages i32) (local $grow_by i32)");
    emitter.indent();
    emitter.push_line("local.get $size");
    emitter.push_line("i32.const 7");
    emitter.push_line("i32.add");
    emitter.push_line("i32.const -8");
    emitter.push_line("i32.and");
    emitter.push_line("local.set $size");
    emitter.push_line("local.get $size");
    emitter.push_line("call $bd_alloc_from_free");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("call $bd_gc_collect");
    emitter.push_line("drop");
    emitter.push_line("local.get $size");
    emitter.push_line("call $bd_alloc_from_free");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("global.get $heap");
    emitter.push_line("local.set $ptr");
    emitter.push_line("global.get $heap");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $new_heap");
    emitter.push_line("local.get $new_heap");
    emitter.push_line("i32.const 65535");
    emitter.push_line("i32.add");
    emitter.push_line("i32.const 65536");
    emitter.push_line("i32.div_u");
    emitter.push_line("local.set $pages_needed");
    emitter.push_line("memory.size");
    emitter.push_line("local.set $cur_pages");
    emitter.push_line("local.get $pages_needed");
    emitter.push_line("local.get $cur_pages");
    emitter.push_line("i32.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $pages_needed");
    emitter.push_line("local.get $cur_pages");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $grow_by");
    emitter.push_line("local.get $grow_by");
    emitter.push_line("memory.grow");
    emitter.push_line("i32.const -1");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_ARRAY_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $new_heap");
    emitter.push_line("global.set $heap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_trace_push (param $id i32) (local $sp i32)");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRACE_STACK_PTR_OFFSET}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $sp");
    emitter.push_line("local.get $sp");
    emitter.push_line(format!("i32.const {TRACE_STACK_SLOTS}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_TRACE_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {TRACE_STACK_DATA_OFFSET}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $id");
    emitter.push_line("i32.store");
    emitter.push_line(format!("i32.const {TRACE_STACK_PTR_OFFSET}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_trace_pop (local $sp i32)");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRACE_STACK_PTR_OFFSET}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $sp");
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $sp");
    emitter.push_line(format!("i32.const {TRACE_STACK_PTR_OFFSET}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");
}

pub(super) fn emit_string_runtime(emitter: &mut WatEmitter, allow_from_bytes: bool) {
    let max_len = i32::MAX as i64 - STRING_HEADER_SIZE as i64;
    let max_bytes_len = i32::MAX - ARRAY_HEADER_SIZE;

    emitter.push_line("(func $bd_string_len (param $ptr i32) (result i64)");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("i64.extend_i32_u");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_string_concat (param $a i32) (param $b i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $len_a i32)");
    emitter.push_line("(local $len_b i32)");
    emitter.push_line("(local $total i64)");
    emitter.push_line("(local $size i64)");
    emitter.push_line("(local $ptr i32)");
    emitter.push_line("(local $a_data i32)");
    emitter.push_line("(local $b_data i32)");
    emitter.push_line("(local $dst_data i32)");

    emitter.push_line("local.get $a");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $b");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_a");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_b");

    emitter.push_line("local.get $len_a");
    emitter.push_line("i64.extend_i32_u");
    emitter.push_line("local.get $len_b");
    emitter.push_line("i64.extend_i32_u");
    emitter.push_line("i64.add");
    emitter.push_line("local.set $total");

    emitter.push_line("local.get $total");
    emitter.push_line(format!("i64.const {max_len}"));
    emitter.push_line("i64.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_ARRAY_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $total");
    emitter.push_line(format!("i64.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i64.add");
    emitter.push_line("local.set $size");

    emitter.push_line("local.get $size");
    emitter.push_line("i32.wrap_i64");
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $total");
    emitter.push_line("i32.wrap_i64");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $dst_data");

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $a_data");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $b_data");

    emitter.push_line("local.get $dst_data");
    emitter.push_line("local.get $a_data");
    emitter.push_line("local.get $len_a");
    emitter.push_line("memory.copy");

    emitter.push_line("local.get $dst_data");
    emitter.push_line("local.get $len_a");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $b_data");
    emitter.push_line("local.get $len_b");
    emitter.push_line("memory.copy");

    emitter.push_line("local.get $ptr");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_string_bytes (param $s i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $ptr i32)");

    emitter.push_line("local.get $s");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $s");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $s");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len");

    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.const {max_bytes_len}"));
    emitter.push_line("i32.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_ARRAY_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_ARRAY << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $s");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $len");
    emitter.push_line("memory.copy");

    emitter.push_line("local.get $ptr");
    emitter.dedent();
    emitter.push_line(")");

    if allow_from_bytes {
        emitter.push_line("(func $bd_string_from_bytes (param $arr i32) (result i32)");
        emitter.indent();
        emitter.push_line("(local $len i32)");
        emitter.push_line("(local $ptr i32)");
        emitter.push_line("(local $src i32)");

        emitter.push_line("local.get $arr");
        emitter.push_line("i32.eqz");
        emitter.push_line("if");
        emitter.indent();
        emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
        emitter.push_line("call $bd_trap");
        emitter.dedent();
        emitter.push_line("end");
        emitter.push_line("local.get $arr");
        emitter.push_line("i32.load");
        emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
        emitter.push_line("i32.shr_u");
        emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
        emitter.push_line("i32.ne");
        emitter.push_line("if");
        emitter.indent();
        emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
        emitter.push_line("call $bd_trap");
        emitter.dedent();
        emitter.push_line("end");
        emitter.push_line("local.get $arr");
        emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
        emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
        emitter.push_line("i32.ne");
        emitter.push_line("if");
        emitter.indent();
        emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
        emitter.push_line("call $bd_trap");
        emitter.dedent();
        emitter.push_line("end");

        emitter.push_line("local.get $arr");
        emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
        emitter.push_line("local.set $len");

        emitter.push_line("local.get $arr");
        emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
        emitter.push_line("i32.add");
        emitter.push_line("local.set $src");

        emitter.push_line("local.get $src");
        emitter.push_line("local.get $len");
        emitter.push_line("call $bd_validate_utf8");
        emitter.push_line("i32.eqz");
        emitter.push_line("if");
        emitter.indent();
        emitter.push_line(format!("i32.const {TRAP_UTF8_INVALID}"));
        emitter.push_line("call $bd_trap");
        emitter.dedent();
        emitter.push_line("end");

        emitter.push_line("local.get $len");
        emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
        emitter.push_line("i32.add");
        emitter.push_line("call $bd_alloc");
        emitter.push_line("local.set $ptr");

        emitter.push_line("local.get $ptr");
        emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
        emitter.push_line("i32.store");
        emitter.push_line("local.get $ptr");
        emitter.push_line("i32.const 0");
        emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
        emitter.push_line("local.get $ptr");
        emitter.push_line("i32.const 0");
        emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
        emitter.push_line("local.get $ptr");
        emitter.push_line("local.get $len");
        emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));

        emitter.push_line("local.get $ptr");
        emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
        emitter.push_line("i32.add");
        emitter.push_line("local.get $src");
        emitter.push_line("local.get $len");
        emitter.push_line("memory.copy");

        emitter.push_line("local.get $ptr");
        emitter.dedent();
        emitter.push_line(")");
    }

    emitter.push_line("(func $bd_string_to_i64 (param $ptr i32) (result i64)");
    emitter.indent();
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $idx i32)");
    emitter.push_line("(local $sign i64)");
    emitter.push_line("(local $value i64)");
    emitter.push_line("(local $digit i64)");
    emitter.push_line("(local $ch i32)");
    emitter.push_line("(local $max_div10 i64)");
    emitter.push_line("(local $max_mod i64)");
    emitter.push_line("(local $data i32)");

    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $data");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");
    emitter.push_line("i64.const 1");
    emitter.push_line("local.set $sign");
    emitter.push_line("i64.const 922337203685477580");
    emitter.push_line("local.set $max_div10");
    emitter.push_line("i64.const 7");
    emitter.push_line("local.set $max_mod");

    emitter.push_line("local.get $data");
    emitter.push_line("i32.load8_u");
    emitter.push_line("local.set $ch");
    emitter.push_line("local.get $ch");
    emitter.push_line("i32.const 45");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i64.const -1");
    emitter.push_line("local.set $sign");
    emitter.push_line("i64.const 8");
    emitter.push_line("local.set $max_mod");
    emitter.push_line("i32.const 1");
    emitter.push_line("local.set $idx");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i64.const 0");
    emitter.push_line("local.set $value");

    let exit_label = "str_to_i64_exit";
    let loop_label = "str_to_i64_loop";
    emitter.push_line(format!("block ${exit_label}"));
    emitter.indent();
    emitter.push_line(format!("loop ${loop_label}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${exit_label}"));

    emitter.push_line("local.get $data");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load8_u");
    emitter.push_line("local.set $ch");

    emitter.push_line("local.get $ch");
    emitter.push_line("i32.const 48");
    emitter.push_line("i32.lt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ch");
    emitter.push_line("i32.const 57");
    emitter.push_line("i32.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ch");
    emitter.push_line("i32.const 48");
    emitter.push_line("i32.sub");
    emitter.push_line("i64.extend_i32_u");
    emitter.push_line("local.set $digit");

    emitter.push_line("local.get $value");
    emitter.push_line("local.get $max_div10");
    emitter.push_line("i64.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $value");
    emitter.push_line("local.get $max_div10");
    emitter.push_line("i64.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $digit");
    emitter.push_line("local.get $max_mod");
    emitter.push_line("i64.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_STRING_PARSE}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $value");
    emitter.push_line("i64.const 10");
    emitter.push_line("i64.mul");
    emitter.push_line("local.get $digit");
    emitter.push_line("i64.add");
    emitter.push_line("local.set $value");

    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${loop_label}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $sign");
    emitter.push_line("i64.const -1");
    emitter.push_line("i64.eq");
    emitter.push_line("if (result i64)");
    emitter.indent();
    emitter.push_line("i64.const 0");
    emitter.push_line("local.get $value");
    emitter.push_line("i64.sub");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $value");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_string_from_i64 (param $value i64) (result i32)");
    emitter.indent();
    emitter.push_line("(local $tmp i64)");
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $sign i32)");
    emitter.push_line("(local $ptr i32)");
    emitter.push_line("(local $idx i32)");
    emitter.push_line("(local $digit i64)");
    emitter.push_line("(local $data i32)");

    emitter.push_line("local.get $value");
    emitter.push_line("i64.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {}", STRING_HEADER_SIZE + 1));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("i32.const 48");
    emitter.push_line("i32.store8");
    emitter.push_line("local.get $ptr");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $value");
    emitter.push_line("i64.const 0");
    emitter.push_line("i64.lt_s");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 1");
    emitter.push_line("local.set $sign");
    emitter.push_line("i64.const 0");
    emitter.push_line("local.get $value");
    emitter.push_line("i64.sub");
    emitter.push_line("local.set $tmp");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $sign");
    emitter.push_line("local.get $value");
    emitter.push_line("local.set $tmp");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $len");
    let len_exit = "str_i64_len_exit";
    let len_loop = "str_i64_len_loop";
    emitter.push_line(format!("block ${len_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${len_loop}"));
    emitter.indent();
    emitter.push_line("local.get $tmp");
    emitter.push_line("i64.eqz");
    emitter.push_line(format!("br_if ${len_exit}"));
    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $tmp");
    emitter.push_line("i64.const 10");
    emitter.push_line("i64.div_u");
    emitter.push_line("local.set $tmp");
    emitter.push_line(format!("br ${len_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $len");
    emitter.push_line("local.get $sign");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $len");

    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $data");

    emitter.push_line("local.get $sign");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $data");
    emitter.push_line("i32.const 45");
    emitter.push_line("i32.store8");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $value");
    emitter.push_line("i64.const 0");
    emitter.push_line("i64.lt_s");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i64.const 0");
    emitter.push_line("local.get $value");
    emitter.push_line("i64.sub");
    emitter.push_line("local.set $tmp");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $value");
    emitter.push_line("local.set $tmp");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $idx");

    let digit_exit = "str_i64_digit_exit";
    let digit_loop = "str_i64_digit_loop";
    emitter.push_line(format!("block ${digit_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${digit_loop}"));
    emitter.indent();
    emitter.push_line("local.get $tmp");
    emitter.push_line("i64.eqz");
    emitter.push_line(format!("br_if ${digit_exit}"));
    emitter.push_line("local.get $tmp");
    emitter.push_line("i64.const 10");
    emitter.push_line("i64.rem_u");
    emitter.push_line("local.set $digit");
    emitter.push_line("local.get $tmp");
    emitter.push_line("i64.const 10");
    emitter.push_line("i64.div_u");
    emitter.push_line("local.set $tmp");
    emitter.push_line("local.get $data");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $digit");
    emitter.push_line("i32.wrap_i64");
    emitter.push_line("i32.const 48");
    emitter.push_line("i32.add");
    emitter.push_line("i32.store8");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${digit_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ptr");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_string_eq (param $a i32) (param $b i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $len_a i32)");
    emitter.push_line("(local $len_b i32)");
    emitter.push_line("(local $idx i32)");

    emitter.push_line("local.get $a");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $b");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_a");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_b");

    emitter.push_line("local.get $len_a");
    emitter.push_line("local.get $len_b");
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");

    let exit_label = "str_eq_exit";
    let loop_label = "str_eq_loop";
    emitter.push_line(format!("block ${exit_label}"));
    emitter.indent();
    emitter.push_line(format!("loop ${loop_label}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $len_a");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${exit_label}"));

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load8_u");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load8_u");

    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${loop_label}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i32.const 1");
    emitter.dedent();
    emitter.push_line(")");
}

pub(super) fn emit_bytes_runtime(emitter: &mut WatEmitter) {
    emitter.push_line("(func $bd_bytes_len (param $ptr i32) (result i64)");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("i64.extend_i32_u");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_bytes_eq (param $a i32) (param $b i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $len_a i32)");
    emitter.push_line("(local $len_b i32)");
    emitter.push_line("(local $idx i32)");

    emitter.push_line("local.get $a");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $b");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_BYTES}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_a");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len_b");

    emitter.push_line("local.get $len_a");
    emitter.push_line("local.get $len_b");
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");

    let exit_label = "bytes_eq_exit";
    let loop_label = "bytes_eq_loop";
    emitter.push_line(format!("block ${exit_label}"));
    emitter.indent();
    emitter.push_line(format!("loop ${loop_label}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $len_a");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${exit_label}"));

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load8_u");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load8_u");

    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${loop_label}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("i32.const 1");
    emitter.dedent();
    emitter.push_line(")");
}

pub(super) fn emit_gc_layout_runtime(
    emitter: &mut WatEmitter,
    book_count: i32,
    offsets_base: i32,
    counts_base: i32,
    fields_base: i32,
    heap_start: i32,
    root_ptr_offset: i32,
    root_data_offset: i32,
    root_slots: i32,
    mark_ptr_offset: i32,
    mark_data_offset: i32,
    mark_slots: i32,
    seen_ptr_offset: i32,
    seen_data_offset: i32,
    seen_slots: i32,
) {
    emitter.push_line("(func $bd_object_type (param $ptr i32) (result i32)");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_TYPE_ID_MASK}"));
    emitter.push_line("i32.and");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_array_kind (param $ptr i32) (result i32)");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_ref_count (param $type i32) (result i32)");
    emitter.indent();
    emitter.push_line("local.get $type");
    emitter.push_line(format!("i32.const {book_count}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if (result i32)");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line(format!("i32.const {counts_base}"));
    emitter.push_line("local.get $type");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line(
        "(func $bd_ref_field (param $type i32) (param $idx i32) (result i32)",
    );
    emitter.indent();
    emitter.push_line("(local $count i32)");
    emitter.push_line("(local $offset i32)");
    emitter.push_line("local.get $type");
    emitter.push_line(format!("i32.const {book_count}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const -1");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line(format!("i32.const {counts_base}"));
    emitter.push_line("local.get $type");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.push_line("local.set $count");

    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const -1");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line(format!("i32.const {offsets_base}"));
    emitter.push_line("local.get $type");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.push_line("local.set $offset");

    emitter.push_line(format!("i32.const {fields_base}"));
    emitter.push_line("local.get $offset");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.add");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_gc_layout_sanity (result i32)");
    emitter.indent();
    emitter.push_line("(local $type i32)");
    emitter.push_line("(local $count i32)");
    emitter.push_line("(local $idx i32)");
    emitter.push_line("(local $sum i32)");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $sum");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $type");

    let exit_label = "gc_layout_exit";
    let loop_label = "gc_layout_loop";
    emitter.push_line(format!("block ${exit_label}"));
    emitter.indent();
    emitter.push_line(format!("loop ${loop_label}"));
    emitter.indent();
    emitter.push_line("local.get $type");
    emitter.push_line(format!("i32.const {book_count}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${exit_label}"));

    emitter.push_line("local.get $type");
    emitter.push_line("call $bd_ref_count");
    emitter.push_line("local.set $count");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");

    let inner_exit = "gc_layout_inner_exit";
    let inner_loop = "gc_layout_inner_loop";
    emitter.push_line(format!("block ${inner_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${inner_loop}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${inner_exit}"));

    emitter.push_line("local.get $type");
    emitter.push_line("local.get $idx");
    emitter.push_line("call $bd_ref_field");
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.ge_s");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $sum");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $sum");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${inner_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $type");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $type");
    emitter.push_line(format!("br ${loop_label}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $sum");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(export \"__bd_gc_layout_sanity\" (func $bd_gc_layout_sanity))");

    emitter.push_line("(func $bd_root_push (param $count i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $base i32)");
    emitter.push_line(format!("i32.const {root_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $base");
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.add");
    emitter.push_line(format!("i32.const {root_slots}"));
    emitter.push_line("i32.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_TRACE_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {root_ptr_offset}"));
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.add");
    emitter.push_line("i32.store");
    emitter.push_line("local.get $base");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_root_set (param $slot i32) (param $ptr i32)");
    emitter.indent();
    emitter.push_line(format!("i32.const {root_data_offset}"));
    emitter.push_line("local.get $slot");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_root_pop (param $count i32)");
    emitter.indent();
    emitter.push_line("(local $base i32)");
    emitter.push_line(format!("i32.const {root_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $base");
    emitter.push_line("local.get $count");
    emitter.push_line("local.get $base");
    emitter.push_line("i32.gt_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $base");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $base");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {root_ptr_offset}"));
    emitter.push_line("local.get $base");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_mark_clear");
    emitter.indent();
    emitter.push_line(format!("i32.const {mark_ptr_offset}"));
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.store");
    emitter.push_line(format!("i32.const {seen_ptr_offset}"));
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_mark_push (param $ptr i32)");
    emitter.indent();
    emitter.push_line("(local $sp i32)");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {mark_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $sp");
    emitter.push_line("local.get $sp");
    emitter.push_line(format!("i32.const {mark_slots}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_TRACE_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {mark_data_offset}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.store");
    emitter.push_line(format!("i32.const {mark_ptr_offset}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_mark_pop (result i32)");
    emitter.indent();
    emitter.push_line("(local $sp i32)");
    emitter.push_line(format!("i32.const {mark_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $sp");
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 0");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $sp");
    emitter.push_line(format!("i32.const {mark_ptr_offset}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.store");
    emitter.push_line(format!("i32.const {mark_data_offset}"));
    emitter.push_line("local.get $sp");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_seen_contains (param $ptr i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $idx i32)");
    emitter.push_line("(local $len i32)");
    emitter.push_line(format!("i32.const {seen_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $len");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");
    let exit_label = "seen_exit";
    let loop_label = "seen_loop";
    emitter.push_line(format!("block ${exit_label}"));
    emitter.indent();
    emitter.push_line(format!("loop ${loop_label}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${exit_label}"));
    emitter.push_line(format!("i32.const {seen_data_offset}"));
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 1");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${loop_label}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("i32.const 0");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_seen_add (param $ptr i32)");
    emitter.indent();
    emitter.push_line("(local $len i32)");
    emitter.push_line(format!("i32.const {seen_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.const {seen_slots}"));
    emitter.push_line("i32.ge_u");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_TRACE_OOM}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {seen_data_offset}"));
    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.store");
    emitter.push_line(format!("i32.const {seen_ptr_offset}"));
    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("i32.store");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_free_add (param $ptr i32) (param $size i32)");
    emitter.indent();
    emitter.push_line("(local $prev i32)");
    emitter.push_line("(local $cur i32)");
    emitter.push_line("(local $next i32)");
    emitter.push_line("(local $prev_size i32)");
    emitter.push_line("(local $cur_size i32)");
    emitter.push_line("(local $new_size i32)");

    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_FREE << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $size");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));

    emitter.push_line("global.get $free_list");
    emitter.push_line("local.set $cur");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $prev");
    let insert_exit = "free_insert_exit";
    let insert_loop = "free_insert_loop";
    emitter.push_line(format!("block ${insert_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${insert_loop}"));
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${insert_exit}"));
    emitter.push_line("local.get $cur");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.gt_u");
    emitter.push_line(format!("br_if ${insert_exit}"));
    emitter.push_line("local.get $cur");
    emitter.push_line("local.set $prev");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $cur");
    emitter.push_line(format!("br ${insert_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $prev");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("global.set $free_list");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $cur_size");
    emitter.push_line("local.get $size");
    emitter.push_line("local.get $cur_size");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $new_size");
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $new_size");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $next");
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $next");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $prev");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $prev");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $prev_size");
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $prev_size");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $cur_size");
    emitter.push_line("local.get $prev_size");
    emitter.push_line("local.get $cur_size");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $new_size");
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $new_size");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $next");
    emitter.push_line("local.get $prev");
    emitter.push_line("local.get $next");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_block_size (param $ptr i32) (result i32)");
    emitter.indent();
    emitter.push_line("(local $kind i32)");
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $aux i32)");
    emitter.push_line("(local $size i32)");
    emitter.push_line("(local $elem i32)");

    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line("local.set $kind");

    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $size");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_FREE}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $size");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $size");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_OBJECT}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("i32.const 8");
    emitter.push_line("i32.mul");
    emitter.push_line(format!("i32.const {OBJECT_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $size");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $aux");
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_BOOL}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 4");
    emitter.push_line("local.set $elem");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 1");
    emitter.push_line("local.set $elem");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_REF}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("i32.const 4");
    emitter.push_line("local.set $elem");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("i32.const 8");
    emitter.push_line("local.set $elem");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $len");
    emitter.push_line("local.get $elem");
    emitter.push_line("i32.mul");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $size");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $size");
    emitter.push_line("i32.const 7");
    emitter.push_line("i32.add");
    emitter.push_line("i32.const -8");
    emitter.push_line("i32.and");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_check_header (param $ptr i32)");
    emitter.indent();
    emitter.push_line("(local $kind i32)");
    emitter.push_line("(local $aux i32)");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line("local.set $kind");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $aux");
    emitter.push_line("local.get $aux");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line(format!("i32.const {TRAP_HEAP_HEADER}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $aux");
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_I64}"));
    emitter.push_line("i32.eq");
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_BOOL}"));
    emitter.push_line("i32.eq");
    emitter.push_line("i32.or");
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_U8}"));
    emitter.push_line("i32.eq");
    emitter.push_line("i32.or");
    emitter.push_line("local.get $aux");
    emitter.push_line(format!("i32.const {ARRAY_KIND_REF}"));
    emitter.push_line("i32.eq");
    emitter.push_line("i32.or");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_HEAP_HEADER}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_OBJECT}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_FREE}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line(format!("i32.const {TRAP_HEAP_HEADER}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_gc_sweep (result i32)");
    emitter.indent();
    emitter.push_line("(local $ptr i32)");
    emitter.push_line("(local $end i32)");
    emitter.push_line("(local $kind i32)");
    emitter.push_line("(local $flags i32)");
    emitter.push_line("(local $size i32)");
    emitter.push_line("(local $freed i32)");
    emitter.push_line("global.get $heap");
    emitter.push_line("local.set $end");
    emitter.push_line(format!("i32.const {heap_start}"));
    emitter.push_line("local.set $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $freed");
    emitter.push_line("i32.const 0");
    emitter.push_line("global.set $free_list");
    let sweep_exit = "sweep_exit";
    let sweep_loop = "sweep_loop";
    emitter.push_line(format!("block ${sweep_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${sweep_loop}"));
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $end");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${sweep_exit}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line("local.set $kind");
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_block_size");
    emitter.push_line("local.set $size");
    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_FREE}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $size");
    emitter.push_line("call $bd_free_add");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.set $flags");
    emitter.push_line("local.get $flags");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.and");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $size");
    emitter.push_line("call $bd_free_add");
    emitter.push_line("local.get $freed");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $freed");
    emitter.dedent();
    emitter.push_line("else");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $flags");
    emitter.push_line("i32.const -2");
    emitter.push_line("i32.and");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $size");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $ptr");
    emitter.push_line(format!("br ${sweep_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $freed");
    emitter.push_line("global.set $gc_last_freed");
    emitter.push_line("local.get $freed");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_gc_collect (result i32)");
    emitter.indent();
    emitter.push_line("call $bd_gc_mark_objects");
    emitter.push_line("drop");
    emitter.push_line("call $bd_gc_sweep");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_gc_mark_objects (result i32)");
    emitter.indent();
    emitter.push_line("(local $root_count i32)");
    emitter.push_line("(local $idx i32)");
    emitter.push_line("(local $ptr i32)");
    emitter.push_line("(local $kind i32)");
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $type i32)");
    emitter.push_line("(local $count i32)");
    emitter.push_line("(local $field_idx i32)");
    emitter.push_line("(local $field_off i32)");

    emitter.push_line("call $bd_mark_clear");
    emitter.push_line(format!("i32.const {root_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.push_line("local.set $root_count");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");
    let root_exit = "root_exit";
    let root_loop = "root_loop";
    emitter.push_line(format!("block ${root_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${root_loop}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $root_count");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${root_exit}"));
    emitter.push_line(format!("i32.const {root_data_offset}"));
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.push_line("call $bd_mark_push");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${root_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    let mark_exit = "mark_exit";
    let mark_loop = "mark_loop";
    emitter.push_line(format!("block ${mark_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${mark_loop}"));
    emitter.indent();
    emitter.push_line("call $bd_mark_pop");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${mark_exit}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_seen_contains");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("br ${mark_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_seen_add");
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.or");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));

    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line("local.set $kind");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_OBJECT}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_object_type");
    emitter.push_line("local.set $type");
    emitter.push_line("local.get $type");
    emitter.push_line("call $bd_ref_count");
    emitter.push_line("local.set $count");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $field_idx");
    let scan_exit = "scan_exit";
    let scan_loop = "scan_loop";
    emitter.push_line(format!("block ${scan_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${scan_loop}"));
    emitter.indent();
    emitter.push_line("local.get $field_idx");
    emitter.push_line("local.get $count");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${scan_exit}"));
    emitter.push_line("local.get $type");
    emitter.push_line("local.get $field_idx");
    emitter.push_line("call $bd_ref_field");
    emitter.push_line("local.set $field_off");
    emitter.push_line("local.get $field_off");
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.lt_s");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("br ${scan_exit}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $field_off");
    emitter.push_line("i32.const 8");
    emitter.push_line("i32.mul");
    emitter.push_line(format!("i32.const {OBJECT_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("i32.add");
    emitter.push_line("i64.load");
    emitter.push_line("i32.wrap_i64");
    emitter.push_line("call $bd_mark_push");
    emitter.push_line("local.get $field_idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $field_idx");
    emitter.push_line(format!("br ${scan_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line("local.get $kind");
    emitter.push_line(format!("i32.const {HEAP_KIND_ARRAY}"));
    emitter.push_line("i32.eq");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line(format!("i32.const {ARRAY_KIND_REF}"));
    emitter.push_line("i32.eq");
    let arr_exit = "arr_exit";
    let arr_loop = "arr_loop";
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("block ${arr_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${arr_loop}"));
    emitter.indent();
    emitter.push_line("local.get $idx");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${arr_exit}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 4");
    emitter.push_line("i32.mul");
    emitter.push_line("i32.add");
    emitter.push_line("i32.load");
    emitter.push_line("call $bd_mark_push");
    emitter.push_line("local.get $idx");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $idx");
    emitter.push_line(format!("br ${arr_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line(format!("br ${mark_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");

    emitter.push_line(format!("i32.const {seen_ptr_offset}"));
    emitter.push_line("i32.load");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_gc_mark_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $a i32)");
    emitter.push_line("(local $b i32)");
    emitter.push_line("(local $base i32)");
    let size = OBJECT_HEADER_SIZE + 8;
    emitter.push_line(format!("i32.const {size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $a");
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("i32.const 1");
    emitter.push_line("call $bd_root_push");
    emitter.push_line("local.set $base");
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $a");
    emitter.push_line("call $bd_root_set");

    emitter.push_line(format!("i32.const {size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $b");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {OBJECT_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $b");
    emitter.push_line("i64.extend_i32_u");
    emitter.push_line("i64.store");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {OBJECT_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $a");
    emitter.push_line("i64.extend_i32_u");
    emitter.push_line("i64.store");

    emitter.push_line("call $bd_gc_mark_objects");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(export \"__bd_gc_mark_test\" (func $bd_gc_mark_test))");

    emitter.push_line("(func $bd_gc_sweep_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $a i32)");
    emitter.push_line("(local $b i32)");
    emitter.push_line("(local $c i32)");
    emitter.push_line("(local $base i32)");
    emitter.push_line("(local $freed i32)");
    let size = OBJECT_HEADER_SIZE + 8;
    emitter.push_line(format!("i32.const {size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $a");
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("i32.const 1");
    emitter.push_line("call $bd_root_push");
    emitter.push_line("local.set $base");
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $a");
    emitter.push_line("call $bd_root_set");

    emitter.push_line(format!("i32.const {size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $b");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("call $bd_gc_collect");
    emitter.push_line("local.set $freed");

    emitter.push_line(format!("i32.const {size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $c");

    emitter.push_line("local.get $c");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.eq");
    emitter.push_line("local.get $freed");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.eq");
    emitter.push_line("i32.and");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(export \"__bd_gc_sweep_test\" (func $bd_gc_sweep_test))");

    emitter.push_line("(func $bd_gc_last_freed (result i32)");
    emitter.indent();
    emitter.push_line("global.get $gc_last_freed");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_gc_last_freed\" (func $bd_gc_last_freed))");

    emitter.push_line("(func $bd_heap_high_water (result i32)");
    emitter.indent();
    emitter.push_line("global.get $heap");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_heap_high_water\" (func $bd_heap_high_water))");

    emitter.push_line("(func $bd_gc_split_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $a i32)");
    emitter.push_line("(local $b i32)");
    emitter.push_line("(local $c i32)");
    emitter.push_line("(local $d i32)");
    emitter.push_line("(local $base i32)");
    emitter.push_line("(local $expected i32)");
    let big = ARRAY_HEADER_SIZE + 32;
    let small = ARRAY_HEADER_SIZE + 8;

    emitter.push_line(format!("i32.const {small}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $a");
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_ARRAY << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {ARRAY_KIND_I64}"));
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("i32.const 1");
    emitter.push_line("call $bd_root_push");
    emitter.push_line("local.set $base");
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $a");
    emitter.push_line("call $bd_root_set");

    emitter.push_line(format!("i32.const {big}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $b");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_ARRAY << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 4");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {ARRAY_KIND_I64}"));
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));

    emitter.push_line("call $bd_gc_collect");
    emitter.push_line("drop");

    emitter.push_line(format!("i32.const {small}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $c");

    emitter.push_line(format!("i32.const {small}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $d");

    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {small}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $expected");

    emitter.push_line("local.get $c");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.eq");
    emitter.push_line("local.get $d");
    emitter.push_line("local.get $expected");
    emitter.push_line("i32.eq");
    emitter.push_line("i32.and");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(export \"__bd_gc_split_test\" (func $bd_gc_split_test))");

    emitter.push_line("(func $bd_header_kind_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $ptr i32)");
    emitter.push_line(format!("i32.const {OBJECT_HEADER_SIZE}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", 99 << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_check_header");
    emitter.push_line("i32.const 1");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_header_kind_test\" (func $bd_header_kind_test))");

    emitter.push_line("(func $bd_header_array_aux_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $ptr i32)");
    emitter.push_line(format!("i32.const {ARRAY_HEADER_SIZE}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_ARRAY << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 99");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("call $bd_check_header");
    emitter.push_line("i32.const 1");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_header_array_aux_test\" (func $bd_header_array_aux_test))");

    emitter.push_line("(func $bd_free_list_len (result i32)");
    emitter.indent();
    emitter.push_line("(local $cur i32)");
    emitter.push_line("(local $count i32)");
    emitter.push_line("(local $limit i32)");
    emitter.push_line("global.get $free_list");
    emitter.push_line("local.set $cur");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $count");
    emitter.push_line("i32.const 2048");
    emitter.push_line("local.set $limit");
    let free_len_exit = "free_len_exit";
    let free_len_loop = "free_len_loop";
    emitter.push_line(format!("block ${free_len_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${free_len_loop}"));
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${free_len_exit}"));
    emitter.push_line("local.get $count");
    emitter.push_line("local.get $limit");
    emitter.push_line("i32.ge_u");
    emitter.push_line(format!("br_if ${free_len_exit}"));
    emitter.push_line("local.get $count");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.set $count");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $cur");
    emitter.push_line(format!("br ${free_len_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $count");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_free_list_len\" (func $bd_free_list_len))");

    emitter.push_line("(func $bd_free_list_bytes (result i32)");
    emitter.indent();
    emitter.push_line("(local $cur i32)");
    emitter.push_line("(local $sum i32)");
    emitter.push_line("(local $limit i32)");
    emitter.push_line("global.get $free_list");
    emitter.push_line("local.set $cur");
    emitter.push_line("i32.const 0");
    emitter.push_line("local.set $sum");
    emitter.push_line("i32.const 2048");
    emitter.push_line("local.set $limit");
    let free_bytes_exit = "free_bytes_exit";
    let free_bytes_loop = "free_bytes_loop";
    emitter.push_line(format!("block ${free_bytes_exit}"));
    emitter.indent();
    emitter.push_line(format!("loop ${free_bytes_loop}"));
    emitter.indent();
    emitter.push_line("local.get $cur");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${free_bytes_exit}"));
    emitter.push_line("local.get $limit");
    emitter.push_line("i32.eqz");
    emitter.push_line(format!("br_if ${free_bytes_exit}"));
    emitter.push_line("local.get $sum");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.set $sum");
    emitter.push_line("local.get $cur");
    emitter.push_line(format!("i32.load offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.set $cur");
    emitter.push_line("local.get $limit");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.sub");
    emitter.push_line("local.set $limit");
    emitter.push_line(format!("br ${free_bytes_loop}"));
    emitter.dedent();
    emitter.push_line("end");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $sum");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_free_list_bytes\" (func $bd_free_list_bytes))");

    emitter.push_line("(func $bd_gc_adjacent_free_test (result i32)");
    emitter.indent();
    emitter.push_line("(local $a i32)");
    emitter.push_line("(local $b i32)");
    emitter.push_line("(local $base i32)");
    let adj_size = OBJECT_HEADER_SIZE + 8;
    emitter.push_line("i32.const 2");
    emitter.push_line("call $bd_root_push");
    emitter.push_line("local.set $base");

    emitter.push_line(format!("i32.const {adj_size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $a");
    emitter.push_line("local.get $a");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $a");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $base");
    emitter.push_line("local.get $a");
    emitter.push_line("call $bd_root_set");

    emitter.push_line(format!("i32.const {adj_size}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $b");
    emitter.push_line("local.get $b");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_OBJECT << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 1");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $b");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $base");
    emitter.push_line("i32.const 1");
    emitter.push_line("i32.add");
    emitter.push_line("local.get $b");
    emitter.push_line("call $bd_root_set");

    emitter.push_line("i32.const 2");
    emitter.push_line("call $bd_root_pop");

    emitter.push_line("call $bd_gc_collect");
    emitter.push_line("drop");
    emitter.push_line("call $bd_free_list_len");
    emitter.dedent();
    emitter.push_line(")");
    emitter.push_line("(export \"__bd_gc_adjacent_free_test\" (func $bd_gc_adjacent_free_test))");
}

pub(super) fn emit_io_runtime(emitter: &mut WatEmitter) {
    emitter.push_line("(func $bd_io_print (param $str i32) (result i64)");
    emitter.indent();
    emitter.push_line("(local $len i32)");
    emitter.push_line("local.get $str");
    emitter.push_line("i32.eqz");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_NULL_DEREF}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $str");
    emitter.push_line("i32.load");
    emitter.push_line(format!("i32.const {HEAP_KIND_SHIFT}"));
    emitter.push_line("i32.shr_u");
    emitter.push_line(format!("i32.const {HEAP_KIND_STRING}"));
    emitter.push_line("i32.ne");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {TRAP_KIND_STRING}"));
    emitter.push_line("call $bd_trap");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $str");
    emitter.push_line(format!("i32.load offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $str");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $len");
    emitter.push_line("call $bd_print");
    emitter.push_line("local.get $len");
    emitter.push_line("i64.extend_i32_u");
    emitter.dedent();
    emitter.push_line(")");

    emitter.push_line("(func $bd_io_read_line (result i32)");
    emitter.indent();
    emitter.push_line("(local $len i32)");
    emitter.push_line("(local $ptr i32)");
    emitter.push_line("call $bd_read_line_len");
    emitter.push_line("local.set $len");
    emitter.push_line("local.get $len");
    emitter.push_line("i32.const 0");
    emitter.push_line("i32.lt_s");
    emitter.push_line("if");
    emitter.indent();
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("return");
    emitter.dedent();
    emitter.push_line("end");
    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("call $bd_alloc");
    emitter.push_line("local.set $ptr");
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {}", HEAP_KIND_STRING << HEAP_KIND_SHIFT));
    emitter.push_line("i32.store");
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_FLAGS_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("i32.const 0");
    emitter.push_line(format!("i32.store offset={HEAP_AUX_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line("local.get $len");
    emitter.push_line(format!("i32.store offset={HEAP_LEN_OFFSET}"));
    emitter.push_line("local.get $ptr");
    emitter.push_line(format!("i32.const {STRING_HEADER_SIZE}"));
    emitter.push_line("i32.add");
    emitter.push_line("local.get $len");
    emitter.push_line("call $bd_read_line_fill");
    emitter.push_line("local.get $ptr");
    emitter.dedent();
    emitter.push_line(")");
}
